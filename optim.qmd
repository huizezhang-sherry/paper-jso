---
title: Performance of Jellyfish Search Optimiser on Projection Pursuit Problems
author:
  - name: Alice Anonymous
    email: alice@example.com
    affiliations: 
        - id: some-tech
          name: Some Institute of Technology
          department: Department Name
          address: Street Address
          city: City
          state: State
          postal-code: Postal Code
    attributes:
        corresponding: true
  - name: Bob Security
    email: bob@example.com
    affiliations:
        - id: another-u
          name: Another University
          department: Department Name
          address: Street Address
          city: City
          state: State
          postal-code: Postal Code
  - name: Cat Memes
    email: cat@example.com
    affiliations:
        - ref: another-u
  - name: Derek Zoolander
    email: derek@example.com
    affilations:
        - ref: some-tech
abstract: |
  This is the abstract. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum augue turpis, dictum non malesuada a, volutpat eget velit. Nam placerat turpis purus, eu tristique ex tincidunt et. Mauris sed augue eget turpis ultrices tincidunt. Sed et mi in leo porta egestas. Aliquam non laoreet velit. Nunc quis ex vitae eros aliquet auctor nec ac libero. Duis laoreet sapien eu mi luctus, in bibendum leo molestie. Sed hendrerit diam diam, ac dapibus nisl volutpat vitae. Aliquam bibendum varius libero, eu efficitur justo rutrum at. Sed at tempus elit.
keywords: 
  - projection pursuit
  - optimization
  - jellyfish optimiser
date: last-modified
bibliography: bibliography.bib
format:
  elsevier-pdf:
    keep-tex: true
    journal:
      name: Journal of Multivariate Analysis
      formatting: preprint
      model: 3p
      cite-style: numbername
---

*Let's use British English ("American or British usage is accepted, but not a mixture of these")*

```{r setup, echo = FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tidyverse)
library(ggplot2)
library(patchwork)
```

# Introduction \[Nicolas and Jessica\]

The artificial jellyfish search (JS) algorithm [@chou_novel_2021] is a swarm-based metaheuristic optimisation algorithm inspired by the search behaviour of jellyfish in the ocean. It is one of the newest swarm intelligence algorithms [@rajwar_exhaustive_2023], which was shown to have stronger search ability and faster convergence with few algorithmic parameters compared to classic optimization methods [@chou_novel_2021]-[@chou_recent_2022].

The rest of the paper is organised as follows: @sec-background introduces the projection pursuit method, including the indexes function and optimisation. @sec-theory introduces the jellyfish optimiser and proposes mathematical expressions to measure the . @sec-simulation applies the jellyfish optimiser through different projection pursuit problems with varying dimensions and index functions. @sec-conclusion concludes the paper.

# Projection pursuit, index functions and optimisation \[Di and Sherry\] {#sec-background}

# The jellyfish optimiser and property for good optimisers \[Nicolas and Jessica\] {#sec-theory}

The jellyfish optimiser (JSO) mimics the natural movements of jellyfish, which include passive and active motions driven by ocean currents and their swimming patterns, respectively. In the context of optimization, these movements are abstracted to explore the search space in a way that balances exploration (searching new areas) and exploitation (focusing on promising areas). The algorithm aims to find the optimal solution by adapting the jellyfish's behavior to navigate towards the best solution over iterations [@chou_novel_2021]. 

Below is the pseudo-code for this visualisation application.

[Put the pseudo-code in, add specifics to this visualisation application]

The JSO implementation involves several key parameters that control its search process in optimization problems. These parameters are designed to guide the exploration and exploitation phases of the algorithm. While the specific implementation details can vary depending on the version of the algorithm or its application, we focus on two main parameters that are most relevant to our application: the number of jellyfish and drift.

@laa_using_2020 has proposed five criteria for assessing projection pursuit indexes (smoothness, squintability, flexibility, rotation invariance, and speed). Since not all the properties affects the execution of the optimisation, here we consider the three relevant properties (smoothness, squintability, and speed), and propose three metrics to evaluate these three properties.


## Smoothness

An intuitive way to measure smoothness of a function would be to count how many continuous derivatives exist. To help define smoothness in our context, we can make use of the Sobolev spaces: functions $f$ in the Sobolev space $W^{p,\infty}$ have all derivatives of order less than $p$ continuous. Smoothness would then be the highest $p$ such that the index function belongs to $W^{p,\infty}$. We can relax this and consider $W^{p,q}$ Sobolev spaces.


Consider the following definition of partial derivative. Let $U$ be an open subset of $\mathbf{R}^n$ and $f: U \rightarrow \mathbf{R}$. The partial derivative of function $f$ at the point $\mathbf{a} = (a_1, \ldots, a_n) \in U$ with respective to the $i$-th variable $x_i$ is defined as

$$
\frac{\delta}{\delta x_i} f(\mathbf{a}) =  \lim_{h \rightarrow 0} \frac{f(a_1, \ldots, a_{i-1}, a_i +h, a_{i+1}, \ldots, a_n) - f(a_1 , \ldots, a_i, \ldots, a_n)}{h} = \lim_{h\rightarrow 0} \frac{f(\mathbf{a} + h\mathbf{e_i}) - f(\mathbf{a})}{h}.
$$
where $\mathbf{e_i}$ is the unit vector of the $i$-th variable $x_i$.

If the derivative is not well-defined, we propose to approximate the derivative using the following expression:

$$\frac{1}{n_i}\sum_{i} \frac{\|f(\mathbf{a} + h_i\mathbf{e_i}) - f(\mathbf{a})\|^p}{h_i}$$

where $p \in [0,1]$. The choice of $p$ reflects the penalty behaviour. For the application in this paper, we choose $p = 1$.

- $h_i$ is an neighbourhood area around $a$. We can insert different values of $h$ to approximate the above quantity and observe how this quantity changes.


## Squintability

From the literature, it is commonly understood that a large squint angle implies that the function is easy to optimize, because we do not need to be very close to the perfect view to see the structure. A small squint angle means that the derivative of the index function can still be very large values near the optimal point and will rapidly change as we get even closer to the optimum. As such we can observe the second order gradient, which is the rate of change of gradient, over the space we are searching. For some index functions, the second order gradient is not well-defined, we can approximate the second order gradient vector in similar fashion as the above section.

To the best of our knowledge, this is the first attempt to measure the notion of squintability.

## Speed

The speed of optimizing an index function can be calculated/measured using the computational complexity (in big O notation, with respect to the sample size) of computing the index function.

# Application \[Di and Sherry\] {#sec-simulation}

The jellyfish optimiser has been implemented in the tourr package [@wickham_tourr_2011] and we will use the diagnostic plots proposed in the ferrn package [@RJ-2021-105] to visualise the optimisation process.


## Going beyond 10D

The pipe-finding problem is initially used to investigate indexes and optimisers in @laa_using_2020, and we extend it from a 6D problem to a 12D problem.

Jellyfish optimiser, as a multi-start algorithm, is efficient in \[...\] for high-dimensional problems

```{r echo = FALSE}
load(here::here("data/pipe_better.rda"))
load(here::here("data/pipe_jellyfish.rda"))
```

```{r}
#| fig.width = 6,
#| fig.height = 3,
#| fig.align = "center",
#| fig.cap = "sthis sdfaksdlf"
pipe_better |>
  bind_rows(pipe_jellyfish) |>
  mutate(dim = as.factor(6 + (as.numeric(dim) - 1) * 2)) |>
  ggplot(aes(x = dim, y = index_val, group = interaction(optimiser, dim), color = optimiser)) +
  geom_violin(width = 2, adjust = 0.5, position = position_dodge(width = 0.4)) +
  ggbeeswarm::geom_quasirandom(size = 0.1, width = 0.1, dodge.width = 0.4) +
  theme_bw() +
  scale_y_continuous(breaks = seq(0.85, 1, 0.01)) +
  scale_color_brewer(palette = "Accent") + 
  labs(y = "Index", x = "Dimension")

```

```{r}
#| fig.width = 8,
#| fig.height = 5,
#| fig.align = "center",
#| fig.cap = "sthis sdfaksdlf"
get_proj <- function(data){
  quantiles <- map(1:4, ~data |>
                     filter(dim == .x) |>
                     pull(index_val) |>
                     quantile(seq(0, 1, 0.5), type = 3) |>
                     rev() |>
                     unname())

  res <- map2_dfr(
    unlist(quantiles),
    rep(1:4, each = 3),
    ~ data |>
      filter(dim == .y, index_val == .x) |>
      select(dim, proj, index_val),
    .id = "id"
    ) |>
    unnest(proj) |>
    mutate(index_val = sprintf("%.3f", index_val),
           optimiser = "jellyfish",
           id = (as.numeric(id) - 1) %%3 + 1,
           dim = as.factor(6 + (as.numeric(dim) - 1) * 2)) |>
    mutate(id = case_when(id == 1 ~ "best",
                          id == 2 ~ "mean",
                          id == 3 ~ "worst",
                          TRUE ~ "0thers"))
  return(res)
}


p1 <- get_proj(pipe_jellyfish)  |>
  ggplot(aes(x = V1, y = V2)) +
  geom_point(size = 0.1) +
  geom_text(data = ~. |> distinct(id, dim, index_val),
           aes(label = index_val), x =0, y = 3.7, size = 3) +
  facet_grid(dim ~ id) +
  xlim(-4, 4) + ylim(-4, 4) +
  theme_bw() +
  theme(aspect.ratio = 1, axis.ticks = element_blank(),
        axis.text = element_blank(), axis.title = element_blank(),
        panel.grid = element_blank())
p2 <- p1 %+% get_proj(pipe_better)
p1 + ggtitle("The Jellyfish Optimiser") | p2 + ggtitle("The Better Optimiser")


```

## On skewness and kurtosis index

## Another data example

# Conclusion \[Di and Sherry\] {#sec-conclusion}

<!-- # Bibliography styles -->

<!-- Here are two sample references:  @Feynman1963118 @Dirac1953888. -->

<!-- By default, natbib will be used with the `authoryear` style, set in `classoption` variable in YAML.  -->

<!-- You can sets extra options with `natbiboptions` variable in YAML header. Example  -->

<!-- ``` -->

<!-- natbiboptions: longnamesfirst,angle,semicolon -->

<!-- ``` -->

<!-- There are various more specific bibliography styles available at -->

<!-- <https://support.stmdocs.in/wiki/index.php?title=Model-wise_bibliographic_style_files>.  -->

<!-- To use one of these, add it in the header using, for example, `biblio-style: model1-num-names`. -->

<!-- ## Using CSL  -->

<!-- If `cite-method` is set to `citeproc` in `elsevier_article()`, then pandoc is used for citations instead of `natbib`. In this case, the `csl` option is used to format the references. By default, this template will provide an appropriate style, but alternative `csl` files are available from <https://www.zotero.org/styles?q=elsevier>. These can be downloaded -->

<!-- and stored locally, or the url can be used as in the example header. -->

<!-- # Equations -->

<!-- Here is an equation: -->

<!-- $$  -->

<!--   f_{X}(x) = \left(\frac{\alpha}{\beta}\right) -->

<!--   \left(\frac{x}{\beta}\right)^{\alpha-1} -->

<!--   e^{-\left(\frac{x}{\beta}\right)^{\alpha}};  -->

<!--   \alpha,\beta,x > 0 . -->

<!-- $$ -->

<!-- Inline equations work as well: $\sum_{i = 2}^\infty\{\alpha_i^\beta\}$ -->

<!-- # Figures and tables -->

<!-- @fig-meaningless is generated using an R chunk. -->

<!-- ```{r} -->

<!-- #| label: fig-meaningless -->

<!-- #| fig-cap: A meaningless scatterplot -->

<!-- #| fig-width: 5 -->

<!-- #| fig-height: 5 -->

<!-- #| fig-align: center -->

<!-- #| out-width: 50% -->

<!-- #| echo: false -->

<!-- plot(runif(25), runif(25)) -->

<!-- ``` -->

<!-- # Tables coming from R -->

<!-- Tables can also be generated using R chunks, as shown in @tbl-simple example. -->

<!-- ```{r} -->

<!-- #| label: tbl-simple -->

<!-- #| tbl-cap: Caption centered above table -->

<!-- #| echo: true -->

<!-- knitr::kable(head(mtcars)[,1:4]) -->

<!-- ``` -->

# References
